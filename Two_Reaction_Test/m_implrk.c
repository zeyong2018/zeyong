#define _CRT_SECURE_NO_WARNINGS
#include "stdafx.h"
#include <basis.h>         /*  for  umleiten, fprintf, stderr, scanf, */
                           /*       printf, readln, LZP, REAL, LZS,   */
                           /*       ONE, fehler_melden                */
#include <vmblock.h>       /*  for  vmalloc, vmcomplete, vmfree,      */
                           /*       vminit, VEKTOR                    */
#include <implruku.h>      /*  for  implruku                          */
#include <t_dgls.h>        /*  for  bsptyp, dgls_waehlen              */
#ifdef __TURBOC__
#ifdef __MSDOS__
#include <alloc.h>         /*  for  coreleft                          */
#endif
#endif



/* ------------------------------------------------------------------ */

int main
        (
         int  argc,
         char *argv[]
        )

/***********************************************************************
*                                                                      *
* Test program for the function implruku() from the module  implruku   *
* to solve a first order ordinary system of differential equations     *
* using implicit Runge-Kutte methods.                                  *
*                                                                      *
* Scope of program:                                                    *
* =================                                                    *
* The program reads the input data from the file stdin and writes      *
* output onto the file stdout.                                         *
* If the first command line entry exists, it is interpreted to be the  *
* input file and this is assigned to stdin.                            *
* The second command line parameter is treated analogously wrt. stdout.*
* Calls for input are directed to stderr which also collects error     *
* messages.                                                            *
*                                                                      *
* After reading the input, it is put out for control purposes; then    *
* the implicit Runge-Kutta method is performed and the computed        *
* results are put out.                                                 *
*                                                                      *
* To solve a differential equation, please proceed as in example       *
* t_dgls.c.                                                            *
*                                                                      *
* Construction of input data files:                                    *
* =================================                                    *
* bspnummer  Number of DE system in t_dgls.c                           *
* mmax       maximal order for the implicit Runge-Kutta method used    *
* epsm       machine constant                                          *
* epsrel     relative error bound                                      *
* stuetzdat  Name of file with the nodes needed in implruku() (this    *
*            will be generated by implruku() if necessary)             *
* ausdat     Name of file used by implruku() for intermediate values,  *
*            unless an empty string is given                           *
* prodat     Name of file where implruku() keeps the protocol of the   *
*            computations, unless an empty string is given             *
* x0         initial x-value                                           *
* y0[0]   \  initial y-value at x0                                     *
* ...      >                                                           *
* y0[n-1] /                                                            *
* xend       final desired x-value                                     *
*                                                                      *
* The number n of differential equations follows from the number of    *
* the DE system chosen; it is stored in conjunction with the right     *
* hand side function in t_dgls.c.                                      *
***********************************************************************/

{
  REAL   x0,
         xend,
         *y0,
         *y,
         *yex,             /* [0..n-1] vector with the exact solution */
         *g,
         epsm,
         epsrel;
  int    n,
         mmax,
         fehler,
         bspnummer,
         i;
  char   stuetzdat[80],
         ausdat[80],
         prodat[80];
  bsptyp *beispiel;
  long   fmax,
         aufrufe;
  void   *vmblock;                    /* List of dynamic allocations */


  if ((fehler = umleiten(argc, argv))   /* assign input/output files  */
      != 0)                             /* to standard ones           */
    return fehler;                                          /* 1 or 2 */


  /* -------------------- read input data --------------------------- */

#ifdef INTERAKTIV
  fprintf(stderr, "\nExample:                          ");
#endif
  scanf("%d", &bspnummer);
  readln();
  if ((beispiel = dgls_waehlen(bspnummer)) == NULL)
  {
    fehler_melden("non existing example number",
                  0, __FILE__, __LINE__);
    return 3;
  }

  n = beispiel->n;
  vmblock = vminit();                           /* initialize storage */
  y0  = (REAL *)vmalloc(vmblock, VEKTOR, n, 0);
  y   = (REAL *)vmalloc(vmblock, VEKTOR, n, 0);
  yex = (REAL *)vmalloc(vmblock, VEKTOR, n, 0);
  g   = (REAL *)vmalloc(vmblock, VEKTOR, n, 0);
  if (! vmcomplete(vmblock))
  {
    fehler_melden("lack of memory", 0, __FILE__, __LINE__);
    return 4;
  }

#ifdef INTERAKTIV
  fprintf(stderr, "maximal order for method mmax:    ");
#endif
  scanf("%d", &mmax);
  readln();

#ifdef INTERAKTIV
  fprintf(stderr, "initial x-value x0:               ");
#endif
  scanf("%"LZS"f", &x0);
  readln();

#ifdef INTERAKTIV
  fprintf(stderr, "final desired x-value  xend:      ");
#endif
  scanf("%"LZS"f", &xend);
  readln();

  for (i = 0; i < n; i++)
  {
#ifdef INTERAKTIV
    fprintf(stderr, "Function value y0[%d] at x0:       ", i);
#endif
    scanf("%"LZS"f", y0 + i);
  }
  readln();

  for (i = 0; i < n; i++)
  {
#ifdef INTERAKTIV
    fprintf(stderr, "Weight g[%d] for y[%d]:             ", i, i);
#endif
    scanf("%"LZS"f", g + i);
  }
  readln();

#ifdef INTERAKTIV
  fprintf(stderr, "Name of node file:                ");
#endif
  getline(stuetzdat, 80);

#ifdef INTERAKTIV
  fprintf(stderr, "Name of intermediate values file: ");
#endif
  getline(ausdat, 80);

#ifdef INTERAKTIV
  fprintf(stderr, "Name of protocol file:            ");
#endif
  getline(prodat, 80);

#ifdef INTERAKTIV
  fprintf(stderr, "Machine constant epsm:            ");
#endif
  scanf("%"LZS"f", &epsm);
  readln();

#ifdef INTERAKTIV
  fprintf(stderr, "relative error bound epsrel:      ");
#endif
  scanf("%"LZS"f", &epsrel);
  readln();

#ifdef INTERAKTIV
  fprintf(stderr, "maximal number of calls of dgl(): ");
#endif
  scanf("%ld", &fmax);
  readln();


  /* ------------ put out input data -------------------------------- */

  printf("\n"
         "Solve a first order ordinary system of DEs\n"
         "==========================================\n"
         "using implicit Runge-Kutta methods\n"
         "==================================\n\n\n"
         "System of DEs:\n"
         "--------------\n"
         "%s\n\n"
         "Input data:\n"
         "-----------\n"
         "Example   = %24d\n"
         "n         = %24d\n"
         "mmax      = %24d\n"
         "epsm      = %24.15"LZP"e\n"
         "epsrel    = %24.15"LZP"e\n"
         "stuetzdat = %24s\n"
         "ausdat    = %24s\n"
         "prodat    = %24s\n"
         "fmax      = %24ld\n"
         "x0        = %24.15"LZP"e\n"
         "xend      = %24.15"LZP"e\n",
         (*beispiel->dgl_text)(), bspnummer, n, mmax, epsm, epsrel,
         stuetzdat, ausdat, prodat, fmax, x0, xend);

  for (i = 0; i < n; i++)
    printf("y0[%d]     = %24.15"LZP"e\n", i, y0[i]);


  /* ------------ solve DE system ----------------------------------- */
#ifdef INTERAKTIV
#ifdef __TURBOC__
#ifdef __MSDOS__
  fprintf(stderr, "\nfree before:  %u\n", coreleft());
#endif
#endif
#endif
  fehler = implruku(beispiel->rechte_seite, n, mmax, stuetzdat, ausdat,
                    prodat, epsm, &epsrel, fmax, &aufrufe, g, &x0, xend,
                    y0, y);
#ifdef INTERAKTIV
#ifdef __TURBOC__
#ifdef __MSDOS__
  fprintf(stderr, "free after:   %u\n", coreleft());
#endif
#endif
#endif


  /* -------------------- put out results -------------------------- */

  printf("\n\n"
         "Output data:\n"
         "------------\n"
         "error code from implruku(): %24d\n"
         "number of calls of dgl():   %24ld\n"
         "final x-value:              %24.15"LZP"e\n"
         "relative error estimate:    %24.15"LZP"e\n\n",
         fehler, aufrufe, x0, epsrel);

  for (i = 0; i < n; i++)
    if (i == 0)
      printf("approximate solution y(x0):          %24.15"LZP"e\n",
             y[i]);
    else
      printf("                                     %24.15"LZP"e\n",
             y[i]);

  if (beispiel->exakte_loesung != NULL)       /* exact solution       */
  {                                           /* available?           */
    (*beispiel->exakte_loesung)(x0, yex);
    printf("\n");
    for (i = 0; i < n; i++)
      if (i == 0)
        printf("'exact' solution  y(x0):             %24.15"LZP"e\n",
               yex[i]);
      else
        printf("                                     %24.15"LZP"e\n",
               yex[i]);
    printf("\n");
    for (i = 0; i < n; i++)
      if (i == 0)
        printf("approx. solution - 'exact' solution: %24.15"LZP"g\n",
               y[i] - yex[i]);
      else
        printf("                                     %24.15"LZP"g\n",
               y[i] - yex[i]);
  }

  if (fehler != 0)
  {
    fehler_melden("implruku()", 10 + fehler, __FILE__, __LINE__);
    return 10 + fehler;
  }


  return 0;
}
